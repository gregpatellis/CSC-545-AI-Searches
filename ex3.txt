3.1
Guaranteed to be optimal for w being greater than or equal to 0 and less than or equal to 1. Scaling g(n) by a constant does not have an effect on the relative ordering of the chosen paths.
If w is greater than one then wh(n) may overestimate the distance to the goal state, making the heuristic not admissible. If w is less than or equal to one then it will lower the estimation,
 with a guarantee to underestimate the distance to the goal.

w     | F(n)            | Search
0     | F(n) = 2g(n)    | Uniformed best-first search
1     | F(n) = g(n)+h(n)|  A* search
2     | F(n) = 2h(n)    |Greedy best-first search
 

3.2

1.x * y possible states, there are infinite paths to the goal because loops are a possibility.

2.The shortest distance between any two points is a straight line. The shortest distance between two points with a convex polygon in the way is to get as close to the edges of the shapes as possible.
 The state space is therefore defined as the points along the polygons as well as the starting and goal points. The state space is equal to the sum of the polygons’ perimeters plus the starting and goal states.

3.State space => Coordinate class including current coordinate position, the goal, and predecessor. Includes methods to access these attributes as well as the predecessor, test for equality, 
calculate straight-line distance to the goal, and test for competition. Another class will be named CoordSuccessor and will have a function called getFringe.
 It will take the current state’s coordinates as input and return all successors in an array.


Example of how to go from start to sucessors.

Array getFringe(currentCoord)
{
	if(currentCoord.equals(cord0))
	{
		// add successors of cord 0 to array
	}
}
	//other states treated the same. Heuristic function:
int distanceToGoal()
{
	int distance = 0;
	distance += Math.sqrt(Math.pow(goal.xpostition.x,2)+Math.pow(goal.yposition.y,2));
	return distance;
}

